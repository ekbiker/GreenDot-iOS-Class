{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf820
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red38\green38\blue38;\red255\green255\blue255;\red128\green0\blue128;
\red0\green0\blue0;\red50\green50\blue50;\red0\green0\blue0;\red0\green116\blue0;\red152\green27\blue126;
}
{\*\expandedcolortbl;;\cssrgb\c20000\c20000\c20000;\cssrgb\c100000\c100000\c100000;\csgenericrgb\c50000\c0\c50000;
\csgenericrgb\c0\c0\c0;\cssrgb\c25490\c25490\c25490;\cssrgb\c0\c0\c0;\csgenericrgb\c0\c45600\c0;\cssrgb\c66667\c20000\c56863;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid1\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{hyphen\}}{\leveltext\leveltemplateid2\'01\uc0\u8259 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{hyphen\}}{\leveltext\leveltemplateid3\'01\uc0\u8259 ;}{\levelnumbers;}\fi-360\li2160\lin2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{hyphen\}}{\leveltext\leveltemplateid4\'01\uc0\u8259 ;}{\levelnumbers;}\fi-360\li2880\lin2880 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww13760\viewh16180\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\b\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
II. Sample App Demo
\b0  (If done in time, else just demo partial app)\
	a. How to run the app on the simulator\
	    Command-R\
\

\b II. 
\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 Xcode Overview\
	
\b0 a. Tabs: each tab is like a separate window, Command-T to add a new tab\
	b. Window Panes:\
		i. Project Navigator (various icons on top, highlight the mostly used ones...), \
		ii. Inspector\
		iii. Editor: \
		    Command-Option-Enter (open counterpart in second editor from an nib file...)\
		iv. Console (log output)\
		iiv. Option-Click on a file to open in second editor pane\
	c. Demo keyboard shortcuts, \
		i. Command-Click (jump to definition) \
		ii. Option-Click (see info popup)\
		iii. Command-Shift-O (quick open) \
		iv. Command-Control <arrow keys> (back or forward one file)\
		v. Command-Shift-F (global find)\
		vi. Command-F (find within file)\
	d. Editor pane:\
		i. Bread crumb nav (Related Items)\
		ii. Split pane view\
	e. Console pane:\
		i. How to set break-points, \
		ii. Debugger variables pane\
		iii. Filters\
		iv. Debug navigator (view hierarchy debugging)\
	f. Source Control Integration\
	g. Preferences (Behaviors, Accounts, etc...)\
	\
\

\b\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
III. Swift Concepts\

\b0 	
\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 1. How to use playground\
	2. 
\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
Comments, single line, multiline\
	3. Declare variables \
		a. var... \
		b. let... \
		c. Naming conventions: (must start with letter)\
			i. Class or Type title case\
			ii. variables and methods camel case\
		d. Define an explicit type (Swift inference)\
		e. Special shorthand (syntactical sugar)\
			i. Array\
			ii. Dictionary\
			iii. Optional\
		f. Named types: (explicitly named)\
			- ints, floats, booleans, strings, (primitive types in other languages are just named types in Swift, \
			  as is any custom class.  ex: Int are just implemented using struct )\
		g. Compound types: (takes no name): tuples, functions (closures, lambdas)\
\
		
\i demo
\i0 : 
\i Swift basics.playground
\i0 \
\
	4. Types: Discuss types in general and then go into details for each, below\
		a. All Swift types derive from four basic constructs: 
\i class
\i0 , 
\i struct
\i0 , 
\i enum
\i0 , 
\i protocol\
			
\i0 i. all other types are built based on one of these - simple and extensible\
			ii. each constructs is especially tailored for a particular use case\
			iii. constructs share many similarities, 
\i structs
\i0  and 
\i enums
\i0  can have methods as in 
\i classes\
				1. struct: 
\i0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0  suited for representing a collection of properties\
				    cannot be subclassed, can conform to protocols, can contain methods, can contain stored and\
				    computed properties
\i\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
\
				2. enum: 
\i0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0  suited for representing a list of cases, each case can have distinct types
\i\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
\
				    
\i0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 cannot be subclassed, can conform to protocols, can contain methods, can contain computed 					     properties
\i\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
\
				3. protocol: 
\i0  like interfaces
\i \
				   
\i0 can implement any other protocols, only computed properties, can contain default \
				   implementations
\i \
			
\i0 iv. don't get stuck on the idea that a Custom Type in Swift must be a class\
		b. value types: 
\i structs
\i0 , 
\i enums
\i0  (difference is in the copying - arguments and assignments)\
		    ex: why is this significant?  (main advantage is Thread safety, copying is optimized)\
		c. reference types: 
\i classes
\i0 \
		d. nested types (
\i structs
\i0 , 
\i enums
\i0 , 
\i classes
\i0  can be nested inside of each other)\
		e. typealias\
		f. extensible - named types only\
			i. you can extend any named Type, even system provided Types\
			ii. used to separate implementation\
			iii. used to provide private implementation\
		g. casting: casting is allowed between super class and sub classes, and "bridged" classes, and checking\
		    for protocol conformance\
			i. \cf4 is\cf2   and \cf4 as\
			\cf5 iii. \cf4 Any\cf5  and \cf4 AnyObject\cf5  (classes only)\cf4 \
			\cf5 iii. unrelated types can't be cast\cf2 \
		h. initializers: All properties must be defined after init\
			i. stored, non-lazy, and non-optional properties must have a value after init\
			ii. alternatively, set a default value in the property declaration\
			iii. property observers, if defined, are not called\
			iv. looks like a function and follows function parameter rules, but no return value and automatic label\
			v. constants CAN be assigned to at initialization time, but not by any subclass\
			vi. For classes: designated initializers and convenience initializers\
			    	1. \cf6 \cb3 Designated initializers must always delegate up\cf0 \cb1 \
\pard\tx2380\tx2880\pardeftab720\li2880\fi-2880\partightenfactor0
\ls1\ilvl3\cf6 \cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8259 	}2. \expnd0\expndtw0\kerning0
Convenience initializers must always delegate across\
\pard\tx2380\tx2880\tx3600\pardeftab720\li2880\fi-2880\partightenfactor0
\ls1\ilvl3\cf2 \cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8259 	}3. Two phased: Default values are assigned first and then given to initializers to perform further customization \
\pard\pardeftab720\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
			viI. failable initializers\
\

\i 		demo
\i0 : 
\i Swift basics.playground
\i0 \
\
	5. Classes:\
		a. Stored properties\
		b. Computed properties\
		c. Static properties\
		d. Functions\
		e. Static functions\
		\
		
\i demo
\i0 : 
\i Class.playground\

\i0 \
	
\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 5. Enums:\
		a. enums are especially suited for representing a list of cases, or group distinct but related types and refer to them\
		    as a common type\
		b. enums cannot be subclassed, but can conform to protocols\
		c. enums can contain methods and properties, but only computed properties\
		d. enums are Types in their own right and can have class like attributes, but they are always passed by \
                          value, NOT reference\
		e. cases do not have to have values. But if they are assigned, it can be String, Int, Float, or Character.\
		f. cases can specify associated values (AssociatedTypes) \
		   
\i note
\i0 : These are like union or variant in other languages (like varients in C#, Java doesn\'92t have \
		   these but you can use Object)\
		
\f1\fs22 \cf8 \CocoaLigature0 //an Optional is implemented using generics and enum
\f0\fs24 \cf0 \CocoaLigature1 \
\
		
\i demo
\i0 : 
\i\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
Enum.playground
\i0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\
	6. Structs:\
		a. structs are especially suited for representing a collection of properties\
		b. structs cannot be subclassed, but can conform to protocols\
		c. structs can contain methods and stored properties, but these properties are always stored as value types\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 		d. structs are Types in their own right and can have class like attributes, but they are always passed by \
                         value NOT reference\
		e. In practice, most custom data structures should be classes, not structs\
		\
		
\i demo: ? 
\i0 TODO\

\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 	7. Protocols: (like interfaces in Java)  TODO: list out basic rules\
		a. can have methods, but only computed properties\
		a. protocols can inherit from other protocols\

\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
		b. \
\
		
\i\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 demo: ?  
\i0 TODO
\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\partightenfactor0

\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 	8. Access Modifiers - least restrictive to the most restrictive\
		
\i \cf4 open
\i0 \cf0  - open to the world. If applied to a class, it can be subclassed. If applied to a method, it can be overridden.\
		
\i \cf4 public
\i0 \cf0  - open to the world, but cannot be subclassed or overridden by the world\
		
\i \cf4 internal
\i0 \cf0  - available only within the module\
		
\i \cf4 fileprivate
\i0 \cf0  - available only within the file\
		
\i \cf4 private
\i0 \cf0  - available only within the immediate declaration scope\
		\
		
\i \cf4 final 
\i0 \cf0  - can't override for methods\
		
\i \cf4 static 
\i0 \cf0  - can't override for type methods\
		
\i \cf4 class -
\i0 \cf0  override for type methods\
	\
	9. Optionals: very special type in Swift\
		a. implemented using an enum, let's apply what we already know about enums.\
		b. forced unwrapping \
		c. chaining, safer than forced unwrapping. Chaining can go several levels deep.\
		d. optional binding, \cf4 if let\cf0 , \cf4 guard let else\cf0 \
		\
\pard\pardeftab720\partightenfactor0

\i \cf0 		demo
\i0 : 
\i\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
Optionals.playground
\i0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
	10. Functions:\
		a. default parameters\
		b. automatic overloads\
		c. inner functions (nested functions)\
		d. ending closures, (blocks, lambdas)\
		e. parameter passing (value or reference)\
		f. variadic parameters TODO\
		g. return tuples\
		h. @
\f1\fs23\fsmilli11900 \cf9 \cb3 \expnd0\expndtw0\kerning0
escaping
\f0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0  (if you want the closure to execute after the function returns)\
			1. the compiler assumes closure parameters are non-escaping by default\
			2. the compiler can make better optimizations by knowing this\
\
\pard\pardeftab720\partightenfactor0

\i \cf0 		demo
\i0 : 
\i\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
Functions.playground
\i0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
	11. Metatype Type (
\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
Dynamic Run Time Typing)
\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 :\
		i. when we need to represent a runtime value for a type (not an instance of a type).  A value must have a type.\
		ii. metatypes are useful when the exact type isn't know at compile time, or in generic functions\
		
\fs28 \cf6 \cb3 \expnd0\expndtw0\kerning0
		\
\pard\pardeftab720\partightenfactor0

\i\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 		demo
\i0 : 
\i\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
MetaTypes.playground\

\i0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 	12. Generics:\
		i. Generic code enables you to write flexible, reusable functions and types that can work with any type\
		ii. much of Swift standard library is written using generics\
		iii. Generic Functions\
		iv. Generic Types\
		v. Type constraints (protocol composition types: protocol1 & protocol2)\
		//vi. where clause??  TODO\
		\
\pard\pardeftab720\partightenfactor0

\i \cf0 		demo
\i0 : 
\i\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
Generics.playground
\i0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
	13 Control structures: OPTIONAL\
		for in\
		while\
		switch\
		if then else, else if\
		\
	14. Operators: OPTIONAL\
		a. 
\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
Ternary
\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
		b. Range\
		c. math\
		e. custom operators\
		f. overriding system operators
\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\partightenfactor0
\cf2 \

\b IV. Application Life-cycle\
	//MIGHT DO THIS IN NEXT LESSON
\b0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 	How to Initialize the application and build the first page using Interface Builder.
\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
\
}